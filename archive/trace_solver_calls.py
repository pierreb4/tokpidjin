"""
Solver Call Tracer Script

This script analyzes the module_stats.json file to extract information about
function calls made from solvers.py to dsl.py functions.

Usage:
    python trace_solver_calls.py [json_file]
"""

import json
import sys
import os
from collections import defaultdict

def load_stats(filename):
    """Load statistics from the JSON file."""
    with open(filename, 'r') as f:
        return json.load(f)

def extract_solver_calls(stats):
    """Extract calls from solvers.py to dsl.py functions."""
    # Track which DSL functions are called by which solvers
    solver_to_dsl_calls = defaultdict(list)
    dsl_to_solver_calls = defaultdict(list)
    
    # Examine all functions in the stats
    for func_name, func_data in stats.items():
        # Skip if this isn't a DSL function
        if func_name.startswith('solve_'):
            continue
            
        # Check if this function has call site information
        if 'call_sites' not in func_data:
            continue
        
        # Look for call sites from solvers.py
        for call_site, count in func_data['call_sites'].items():
            if 'solvers.py:' in call_site:
                # Extract the solver name from the call site
                solver_line = call_site.split('solvers.py:')[1]
                
                # Find which solver function this is from
                solver_name = None
                for potential_solver in stats:
                    if potential_solver.startswith('solve_') and f"{potential_solver}(" in call_site:
                        solver_name = potential_solver
                        break
                
                # If we couldn't determine the solver, try to get it from the line number
                if not solver_name:
                    solver_name = f"Unknown solver at line {solver_line}"
                
                # Record this call
                solver_to_dsl_calls[solver_name].append({
                    'dsl_function': func_name,
                    'call_site': call_site,
                    'count': count
                })
                
                dsl_to_solver_calls[func_name].append({
                    'solver': solver_name,
                    'call_site': call_site,
                    'count': count
                })
    
    return {
        'solver_to_dsl': solver_to_dsl_calls,
        'dsl_to_solver': dsl_to_solver_calls
    }

def print_solver_dsl_usage(calls):
    """Print information about solver calls to DSL functions."""
    solver_calls = calls['solver_to_dsl']
    dsl_calls = calls['dsl_to_solver']
    
    if not solver_calls and not dsl_calls:
        print("No calls from solvers.py to dsl.py functions were recorded.")
        print("This might be because:")
        print("1. The solvers don't call any DSL functions directly")
        print("2. The statistics collection didn't capture the call site information")
        print("3. The module decorating process didn't work as expected")
        return
    
    print("\n=== DSL Functions Called By Solvers ===")
    for func_name, solvers in sorted(dsl_calls.items(), key=lambda x: len(x[1]), reverse=True):
        total_calls = sum(s['count'] for s in solvers)
        
        # Collect all signatures
        all_signatures = []
        for call_info in solvers:
            if 'signatures' in call_info and call_info['signatures']:
                all_signatures.extend(call_info['signatures'])
        
        signature_display = f" [{', '.join(set(all_signatures[:3]))}]" if all_signatures else ""
        print(f"\n{func_name}: {total_calls} total calls from {len(solvers)} solvers{signature_display}")
        
        # Group by solver for better readability
        by_solver = defaultdict(int)
        for call in solvers:
            by_solver[call['solver']] += call['count']
        
        # Print top 5 solvers using this function
        for solver, count in sorted(by_solver.items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"  {solver}: {count} calls")
    
    print("\n=== Solvers and Their DSL Function Usage ===")
    for solver, calls in sorted(solver_calls.items(), key=lambda x: len(x[1]), reverse=True)[:20]:
        print(f"\n{solver}: uses {len(set(c['dsl_function'] for c in calls))} DSL functions")
        
        # Group by function for better readability
        by_func = defaultdict(int)
        for call in calls:
            by_func[call['dsl_function']] += call['count']
        
        # Print functions used by this solver
        for func, count in sorted(by_func.items(), key=lambda x: x[1], reverse=True)[:10]:
            print(f"  {func}: {count} calls")

# Add a function to load data from track_solver.py format
def load_track_solver_stats(filename):
    """Load statistics generated by track_solver.py with enhanced signature support."""
    with open(filename, 'r') as f:
        track_data = json.load(f)
    
    # Convert to the format used by this script
    solver_name = os.path.basename(filename).split("_dsl_stats.json")[0]
    
    solver_to_dsl_calls = defaultdict(list)
    dsl_to_solver_calls = defaultdict(list)
    
    for func_name, func_data in track_data.items():
        type_signatures = func_data.get('type_signatures', [])
        value_signatures = func_data.get('value_signatures', [])
        
        for call_site, count in func_data.get('call_sites', {}).items():
            # Record for solver-to-dsl mapping
            solver_to_dsl_calls[f"solve_{solver_name}"].append({
                'dsl_function': func_name,
                'call_site': call_site,
                'count': count,
                'type_signatures': type_signatures,
                'value_signatures': value_signatures
            })
            
            # Record for dsl-to-solver mapping
            dsl_to_solver_calls[func_name].append({
                'solver': f"solve_{solver_name}",
                'call_site': call_site,
                'count': count,
                'type_signatures': type_signatures,
                'value_signatures': value_signatures
            })
    
    return {
        'solver_to_dsl': solver_to_dsl_calls,
        'dsl_to_solver': dsl_to_solver_calls
    }

def main():
    """Main function to process command line arguments and display results."""
    # Check for direct solver stats
    if len(sys.argv) > 1 and "_dsl_stats.json" in sys.argv[1]:
        print(f"Processing solver stats from {sys.argv[1]}...")
        calls = load_track_solver_stats(sys.argv[1])
        print_solver_dsl_usage(calls)
        return
        
    # Original functionality
    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        filename = "module_stats.json"
    
    try:
        stats = load_stats(filename)
        calls = extract_solver_calls(stats)
        print_solver_dsl_usage(calls)
    except Exception as e:
        print(f"Error processing {filename}: {e}")
        print("Try using solver stats from track_solver.py instead.")

if __name__ == "__main__":
    main()