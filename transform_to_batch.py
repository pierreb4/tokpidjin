#!/usr/bin/env python3
"""
Transform card.py generated batt into batch-native version

This script transforms a standard batt.py (generated by card.py) into a 
batch-native version that directly calls GPU batch operations.

Usage:
    python transform_to_batch.py -i batt.py -o batt_batch.py

Strategy:
1. Read generated batt.py
2. Transform imports: from pile import * â†’ from gpu_dsl_operations import *
3. Transform function signature: def batt(task_id, S, I, C, log_path)
   â†’ def batt(task_id, S, I, C, log_path) [keep same for compatibility]
4. Transform DSL calls: mapply(f, S) â†’ batch_mapply(f, [S])[0]
   (Process single grid as batch of 1)

Author: Pierre
Date: October 13, 2025
Week: 5 Day 3 - Option 3 Implementation
"""

import re
import argparse
from pathlib import Path


# DSL functions that have batch equivalents
BATCH_FUNCTIONS = {
    'mapply': 'batch_mapply',
    'apply': 'batch_apply',
    # We can add more as needed
}


def transform_imports(content: str) -> str:
    """
    Transform imports to include batch operations.
    
    Keep existing imports but add batch operations.
    """
    # Add batch operations import after dsl or pile import
    if 'from pile import *' in content:
        content = content.replace(
            'from pile import *',
            '''from pile import *
from gpu_dsl_operations import batch_mapply, batch_apply'''
        )
    elif 'from dsl import *' in content:
        content = content.replace(
            'from dsl import *',
            '''from dsl import *
from gpu_dsl_operations import batch_mapply, batch_apply'''
        )
    
    return content


def transform_function_calls(content: str) -> str:
    """
    Transform DSL function calls to batch versions.
    
    Since batt processes one task at a time, we wrap single grids
    in a list and unwrap the result:
        mapply(f, S) â†’ batch_mapply(f, [S])[0]
    """
    transformations = 0
    lines = content.split('\n')
    result_lines = []
    
    for line in lines:
        # Pattern: variable = function(args)
        match = re.match(r'(\s+)(\w+)\s*=\s*(\w+)\((.*)\)$', line)
        
        if match:
            indent, var_name, func_name, args = match.groups()
            
            # Check if this is a DSL function we want to batch
            if func_name in BATCH_FUNCTIONS:
                batch_func = BATCH_FUNCTIONS[func_name]
                
                # Wrap collection args in [...]
                # For mapply(f, S) â†’ batch_mapply(f, [S])
                # For apply(f, S) â†’ batch_apply(f, [S])
                
                # Simple approach: wrap the collection argument
                # Split args by comma, wrap second arg (collection)
                arg_parts = [a.strip() for a in args.split(',', 1)]
                if len(arg_parts) == 2:
                    func_arg, collection_arg = arg_parts
                    
                    # Check if collection is S, I, or a t variable
                    if collection_arg in ['S', 'I', 'C'] or collection_arg.startswith('t'):
                        # Transform: mapply(f, S) â†’ batch_mapply(f, [S])[0]
                        new_line = f'{indent}{var_name} = {batch_func}({func_arg}, [{collection_arg}])[0]\n'
                        result_lines.append(new_line)
                        transformations += 1
                        continue
        
        # If not transformed, keep original line
        result_lines.append(line + '\n' if line else '\n')
    
    print(f"âœ… Transformed {transformations} function calls to batch versions")
    return ''.join(result_lines).rstrip('\n') + '\n'


def transform_batt_file(input_file: str, output_file: str) -> None:
    """
    Transform a standard batt.py into batch-native version.
    
    Args:
        input_file: Path to input batt.py
        output_file: Path to output batt_batch.py
    """
    print(f"ðŸ“– Reading {input_file}...")
    with open(input_file, 'r') as f:
        content = f.read()
    
    print(f"ðŸ”„ Transforming imports...")
    content = transform_imports(content)
    
    print(f"ðŸ”„ Transforming function calls...")
    content = transform_function_calls(content)
    
    print(f"ðŸ’¾ Writing {output_file}...")
    with open(output_file, 'w') as f:
        f.write(content)
    
    print(f"âœ… Transformation complete!")
    print(f"   Input: {input_file}")
    print(f"   Output: {output_file}")
    print(f"\nðŸš€ Test with:")
    print(f"   from {Path(output_file).stem} import batt")
    print(f"   result = batt(task_id, S, I, C, 'test.log')")


def main():
    parser = argparse.ArgumentParser(
        description='Transform batt.py to batch-native version'
    )
    parser.add_argument(
        '-i', '--input',
        type=str,
        default='batt.py',
        help='Input batt file (default: batt.py)'
    )
    parser.add_argument(
        '-o', '--output',
        type=str,
        default='batt_batch.py',
        help='Output batch batt file (default: batt_batch.py)'
    )
    
    args = parser.parse_args()
    
    print("=" * 70)
    print("BATCH BATT TRANSFORMER - Option 3")
    print("=" * 70)
    
    transform_batt_file(args.input, args.output)
    
    print("\n" + "=" * 70)
    print("âœ… READY TO TEST")
    print("=" * 70)


if __name__ == '__main__':
    main()
